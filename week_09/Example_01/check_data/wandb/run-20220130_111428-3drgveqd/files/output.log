[1m================================================= test session starts =================================================
platform darwin -- Python 3.9.10, pytest-6.2.5, py-1.11.0, pluggy-1.0.0 -- /Users/ivanovitchsilva/opt/anaconda3/envs/mlflow-646ab37a5ab6e97d711e16eeb4500ce1a8212984/bin/python
cachedir: .pytest_cache
rootdir: /Users/ivanovitchsilva/mlops/week_09/Example_01/check_data
[1mcollected 1 item                                                                                                      
test_data.py::test_kolmogorov_smirnov    39          State-gov   77516   Bachelors   13  ...  2174  0  40   United-States   <=50K
0  50   Self-emp-not-inc   83311   Bachelors   13  ...     0  0  13   United-States   <=50K
1  38            Private  215646     HS-grad    9  ...     0  0  40   United-States   <=50K
2  53            Private  234721        11th    7  ...     0  0  40   United-States   <=50K
3  28            Private  338409   Bachelors   13  ...     0  0  40            Cuba   <=50K
4  37            Private  284582     Masters   14  ...     0  0  40   United-States   <=50K
[5 rows x 15 columns]
   39          State-gov   77516   Bachelors   13  ...  2174  0  40   United-States   <=50K
0  50   Self-emp-not-inc   83311   Bachelors   13  ...     0  0  13   United-States   <=50K
1  38            Private  215646     HS-grad    9  ...     0  0  40   United-States   <=50K
2  53            Private  234721        11th    7  ...     0  0  40   United-States   <=50K
3  28            Private  338409   Bachelors   13  ...     0  0  40            Cuba   <=50K
4  37            Private  284582     Masters   14  ...     0  0  40   United-States   <=50K
[5 rows x 15 columns]
[31mFAILED
====================================================== FAILURES =======================================================
[31m[1m_______________________________________________ test_kolmogorov_smirnov _______________________________________________
self = Index(['39', ' State-gov', ' 77516', ' Bachelors', ' 13', ' Never-married',
       ' Adm-clerical', ' Not-in-family', ' White', ' Male', ' 2174', ' 0',
       ' 40', ' United-States', ' <=50K'],
      dtype='object')
key = 'age', method = None, tolerance = None
    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
>               return self._engine.get_loc(casted_key)
[31m[1m../../../../opt/anaconda3/envs/mlflow-646ab37a5ab6e97d711e16eeb4500ce1a8212984/lib/python3.9/site-packages/pandas/core/indexes/base.py[39m[22m:3361:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
>   ???
[31m[1mpandas/_libs/index.pyx[39m[22m:76:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
>   ???
[31m[1mpandas/_libs/index.pyx[39m[22m:108:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
>   ???
[31m[1mpandas/_libs/hashtable_class_helper.pxi[39m[22m:5198:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
>   ???
[31m[1mE   KeyError: 'age'
[31m[1mpandas/_libs/hashtable_class_helper.pxi[39m[22m:5206: KeyError
[33mThe above exception was the direct cause of the following exception:
data = (       39          State-gov   77516    Bachelors   13  ...   2174  0  40   United-States   <=50K
0      50   Self-em... 52       Self-emp-inc  287927      HS-grad    9  ...  15024  0  40   United-States    >50K
[32536 rows x 15 columns])
ks_alpha = 0.05
    def test_kolmogorov_smirnov(data, ks_alpha):
        sample1, sample2 = data
        numerical_columns = [
            "age",
            "fnlwgt",
            "education_num",
            "capital_gain",
            "capital_loss",
            "hours_per_week"
        ]
        print(sample1.head())
        print(sample2.head())
        # Bonferroni correction for multiple hypothesis testing
        alpha_prime = 1 - (1 - ks_alpha)**(1 / len(numerical_columns))
        for col in numerical_columns:
            # two-sided: The null hypothesis is that the two distributions are identical
            # the alternative is that they are not identical.
            ts, p_value = scipy.stats.ks_2samp(
>               sample1[col],
                sample2[col],
                alternative='two-sided'
            )
[31m[1mtest_data.py[39m[22m:29:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
[31m[1m../../../../opt/anaconda3/envs/mlflow-646ab37a5ab6e97d711e16eeb4500ce1a8212984/lib/python3.9/site-packages/pandas/core/frame.py[39m[22m:3458: in __getitem__
    indexer = self.columns.get_loc(key)
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
self = Index(['39', ' State-gov', ' 77516', ' Bachelors', ' 13', ' Never-married',
       ' Adm-clerical', ' Not-in-family', ' White', ' Male', ' 2174', ' 0',
       ' 40', ' United-States', ' <=50K'],
      dtype='object')
key = 'age', method = None, tolerance = None
    def get_loc(self, key, method=None, tolerance=None):
        """
        Get integer location, slice or boolean mask for requested label.
        Parameters
        ----------
        key : label
        method : {None, 'pad'/'ffill', 'backfill'/'bfill', 'nearest'}, optional
            * default: exact matches only.
            * pad / ffill: find the PREVIOUS index value if no exact match.
            * backfill / bfill: use NEXT index value if no exact match
            * nearest: use the NEAREST index value if no exact match. Tied
              distances are broken by preferring the larger index value.
        tolerance : int or float, optional
            Maximum distance from index value for inexact matches. The value of
            the index at the matching location must satisfy the equation
            ``abs(index[loc] - key) <= tolerance``.
        Returns
        -------
        loc : int if unique index, slice if monotonic index, else mask
        Examples
        --------
        >>> unique_index = pd.Index(list('abc'))
        >>> unique_index.get_loc('b')
        1
        >>> monotonic_index = pd.Index(list('abbc'))
        >>> monotonic_index.get_loc('b')
        slice(1, 3, None)
        >>> non_monotonic_index = pd.Index(list('abcb'))
        >>> non_monotonic_index.get_loc('b')
        array([False,  True, False,  True])
        """
        if method is None:
            if tolerance is not None:
                raise ValueError(
                    "tolerance argument only valid if using pad, "
                    "backfill or nearest lookups"
                )
            casted_key = self._maybe_cast_indexer(key)
            try:
                return self._engine.get_loc(casted_key)
            except KeyError as err:
>               raise KeyError(key) from err
[31m[1mE               KeyError: 'age'
[31m[1m../../../../opt/anaconda3/envs/mlflow-646ab37a5ab6e97d711e16eeb4500ce1a8212984/lib/python3.9/site-packages/pandas/core/indexes/base.py[39m[22m:3363: KeyError
=============================================== short test summary info ===============================================
FAILED test_data.py::test_kolmogorov_smirnov - KeyError: 'age'
[31m================================================= [1m1 failed[22m in 14.63s ==================================================